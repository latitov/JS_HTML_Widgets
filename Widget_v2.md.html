<!DOCTYPE html>
<html><head><link rel="stylesheet" href="github-markdown.css"></head><body>
<textarea id="mydoc-src" style="display: none;">

# How to best create UI widgets in JavaScript/HTML
## Widget architecture for JavaScript/HTML

By Leonid Titov, 2019-09-23

Contents:

- [Part 1. Widget Inclusion and Dir Structure](#part1widgetinclusionanddirstructure)
- [Part 2. Widget Program Architecture](#part2widgetprogramarchitecture)
- [Part 3. Callbacks](#part3callbacks)
- [Part 4. Typical new()](#part4typicalnew)
- [Part 5. Example](#part5example)
- [Part 6. Better idea for new()](#part6betterideafornew)

## Part 1. Widget Inclusion and Dir Structure

A widget as a reusable component is a file with JS code, which is included via this tag:

	<script src="WidgetsLib/a1/Button/js"></script>

A one JS file may contain a whole pack of different widgets:

	<script src="WidgetsLib/all.js"></script>

Note, that a particular widget file, though it's certainly built with build app,
isn't located in _R/. That's for convenience. Instead, the actual structure of a widget dir is this:

	WidgetsLib/a1/Button/
				src/
					actual source code files are here...
				build	Build app
				js	the result of build process


## Part 2. Widget Program Architecture

The widget architecture is as follows:

- 1. CSS literal. All style classes of a widget are put in here.

	Must be injected into the DOM once for all instances of a widget.

- 2. HTML literal. The HTML which will be inserted into the DOM.

	Gets injected into the DOM once per each widget. It _is_ a widget.

- 3. All necessary callbacks, and proper attachment of them to HTML elements.

- 4. A constructor, that makes it all into a real object.

- 5. Each widget must be ID-ed, uniquely.

- 6. Each widget must be placed in proper place in DOM hierarchy, and provided width and height
parameters.

As an example, here's how Google creates a map widget:

	<!DOCTYPE html>
	<html>
	<body>

	<h1>My First Google Map</h1>

	<div id="googleMap" style="width:90%;height:400px;"></div>  --(5)
	
	<script>
	function myMap() { --(2)
		var mapProp= { --(3)
			center:new google.maps.LatLng(51.508742,-0.120850),
			zoom:5,
		};
	var map = new google.maps.Map(document.getElementById("googleMap"),mapProp);   --(4)
	}
	</script>
	
	<script src="https://maps.googleapis.com/maps/api/js?key=API_KEY&callback=myMap"></script> --(1)
	
	</body>
	</html>

The (1) is a weird form of calling a constructor, which then calls (2) callback, which defines (3)
some data structure with parameters for a map to be created. After that, _a second constructor_
called (4), which actually creates a widget in (5) div block. Looks like (1) is a constructor-of-the-constructor,
don't know why they complicated it so much.

But what can be taken useful from this, is the idea that instead of traditional way to create widgets by
calling a constructor and passing it a location _where_ to create it, and also geometry information,
instead we create a widget div right away in HTML, thus providing it with width and height and possibly
other parameters, and properly placing it in the DOM hierarchy, and then just reference it by ID in
the constructor call. It would elegantly solve the 5 and 6 from above list.

An example:

	<!DOCTYPE html>
	<html>
	<body>

	<h1>My First Widget Test</h1>

	<div id="wdg1" style="width: 150px; height: 50px;"></div>
	
	<script>
		var b1 = WidgetsLib.a1.Button.new("wdg1", {
			prop1:	1,
			meth1:	function() { ... },
		});
	</script>
	
	<script src="WidgetsLib/a1/Button/js"></script>
	
	</body>
	</html>

__Note:__ constructor will create a brand new object, and replace wdg1 with it,
and copy all style information from wdg1 to a newly created div. Also id get's copied,
nothing else (callbacks don't).

Once widget lib is included, a structure of the following form is created/updated:

	var WidgetsLib = {
		a1: {
			Button: {
				new: function(...) { ... } // a constructor
				... other global params for all such widgets
			}
		}
	}
	
Thus you can access it with:

	var b1 = WidgetsLib.a1.Button.new(...);

__Important:__ the Button is not an object, and Button.new() doesn't instantiate it.
Instead, the Button is nothing but a namespace, a convenience to organize widgets hierarchically,
keep sane names for everything, and also be able to keep global information on each class
of widgets. Think of it as of a package in Perl.

And so Button.new() is just an __ordinary function__, not a method (though it can access
it's location via `this` syntax). And it creates and returns you an object. It can create
it anyway, and there's no requirement for it to be called `new()`.

## Part 3. Callbacks

Another problem is how to attach callbacks. Some callbacks we could attach directly to the `<div>`,
however that's not the case for complex widgets, and is somehow inconvenient. To standardize this,
let's always define callbacks in the widget object instance. __Here:__ the constructor would register
some properties of our instance as callbacks in DOM; then you can define those instances to actual
functions. Like so:

	var b1 = WidgetsLib.a1.Button.new("wdg1", {
		onclick: function(ev) {
			...
		}
	});

and

	<div onclick="WidgetsLib.a1.Button.onclick(event)"></div>

ughh.. Previously I though it'd be a problem, because we can't pass b1 there,
and so we would need an array of all instances of buttons, and make something like
`<div onclick="WidgetsLib.a1.Button.instances[14].onclick(event)"></div>`. Fortunatelly, __we can__
pass b1 there directly, so there is no problem whatsoever.... Or is there? What if
you re-assign b1, or it goes out of scope? Hm, we still do need an array then.

Each newly created instance would be put into an `instances[]` array, and all callbacks
from DOM would point there. Thus it doesn't matter if you lose b1. This way:

	<div onclick="WidgetsLib.a1.Button.instances[123].onclick(event)"></div>
	

## Part 4. Typical `new()`

Typical form of a widget in a library hierarchy, with the `new()` function, would be this:

	...: {
		CSS_Literal: `
			.{{WIDGET_CLASS_ID}}_Something {
				color: hsl(0, 0%, 20%);
			}
		`,
		HTML_Literal: `
				<div onclick="{{WIDGET_INSTANCE}}.onclick(event)"
				class="{{WIDGET_CLASS_ID}}_Something"
			>
			</div>
		`,
		new: function(dom_id, spec_o) {
			var instance_id = this.instances.length;
			var widget_class_id, widget_path, el;

			[widget_class_id, widget_path] = getMyTreeLocation(this);
			
			if (instance_id == 0) {	// first instance
				el = document.createElement('style');
				el.type = 'text/css';
				el.innerHTML = this.CSS_Literal
					.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id);
				document.getElementsByTagName('head')[0].appendChild(el);
			}
			
			var Widget = {
				// newly created widget
			};
			this.instances.push(Widget);
			
			specialize_with(Widget, spec_o);
			
			var base_el = document.getElementById(dom_id);
			el = document.createElement('div');
			specialize_with(el.style, base_el.style);
			base_el.replaceWith(el);
			el.setAttribute("id", dom_id);
			el.innerHTML = this.HTML_Literal
				.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id)
				.replace(/\{\{WIDGET_INSTANCE\}\}/, `${widget_path}.instances[${instance_id}]`);
			
			Widget.DOM = el;
			return Widget;
		},
	}

`specialize_with()` can be found here: https://github.com/latitov/OOP_MI_Ct_oPlus_in_JS .

Objects to the lib tree are added with this function:

	function addChildToTree(o, childName, childO) {
		o[childName] = childO;
		childO.tree_parent = o;
		childO.tree_name = childName;
	}

To ensure the possibility to find `{{WIDGET_CLASS_ID}}` and `{{WIDGET_INSTANCE}}`. That is done with
this complementary function:

	function getMyTreeLocation(o) {
		var widget_class_id = "", widget_path = "";
		
		while (true) {
			widget_class_id = o.tree_name + widget_class_id;
			widget_path = o.tree_name + widget_path;
			o = o.tree_parent;
			if (o.tree_parent == null) {
				break;
			}
			widget_class_id = "_" + widget_class_id;
			widget_path = "." + widget_path;
		}
		return [widget_class_id, widget_path];
	}

Here's how you use it:

	var T = {
		tree_name: "TheTreeRoot"
	};
	
	addChildToTree(T, "Sub1", {});
	addChildToTree(T.Sub1, "Sub1", {});
	addChildToTree(T.Sub1.Sub1, "xxx", {});

The includable `js` file, registers itself in a tree like this:

	// inside a js file of a widget class
	(function () {
		var Module_Path = [
			"WidgetsLib",
			"a1",
			"Button",
		];
	
		var curr = this;
		Module_Path.forEach(function(i){
			if (curr[i] == null) {
				addChildToTree(curr, i, {});
			}
			curr = curr[i];
		});
	
		specialize_with(curr, {
			new: function() { ...}
		});
	})();

## Part 5. Example

Here's a complete test, a single file logically split in sections.

#### User HTML:

	<!DOCTYPE html>
	<html>
	<body>
	
	<h1 id=t1>-</h1>
	<h3 id=t3>-</h3>
	
	<div id="w1" style="background-color: hsl(200, 50%, 50%);">This will be a widget.</div>
	
	<pre id="dbg"></pre>

	<script>

#### A widget code

		// inside a js file of a widget class
		(function () {
			var Module_Path = [
				"WidgetsLib",
				"a1",
				"Button",
			];
		
			var curr = this;
			Module_Path.forEach(function(i){
				if (curr[i] == null) {
					addChildToTree(curr, i, {});
				}
				curr = curr[i];
			});
		
			specialize_with(curr, {
				CSS_Literal: `
					.{{WIDGET_CLASS_ID}}_Something {
						color: hsl(0, 0%, 20%);
					}
				`,
				HTML_Literal: `
					<div onclick="{{WIDGET_INSTANCE}}.onclick(event)"
						class="{{WIDGET_CLASS_ID}}_Something"
					>
					SOME SUPER COOL WIDGET
					</div>
				`,
				new: function(dom_id, spec_o) {
					if (this.instances == null) { this.instances = []; }
					var instance_id = this.instances.length;
					var widget_class_id, widget_path, el;
		
					[widget_class_id, widget_path] = getMyTreeLocation(this);
					
					if (instance_id == 0) {	// first instance
						el = document.createElement('style');
						el.type = 'text/css';
						el.innerHTML = this.CSS_Literal
							.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id);
						document.getElementsByTagName('head')[0].appendChild(el);
					}
					
					var Widget = {
						// newly created widget
					};
					this.instances.push(Widget);
					
					specialize_with(Widget, spec_o);
					
					var base_el = document.getElementById(dom_id);
					el = document.createElement('div');
					specialize_with(el.style, base_el.style);
					base_el.replaceWith(el);
					el.setAttribute("id", dom_id);
					el.innerHTML = this.HTML_Literal
						.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id)
						.replace(/\{\{WIDGET_INSTANCE\}\}/, `${widget_path}.instances[${instance_id}]`);

					Widget.DOM = el;
					return Widget;
				},
				new_test: function() {
					document.getElementById("t3").innerHTML = "It's new()";
				}
			});
		})();

#### User code

		var widget_class_id, widget_path;
	
		[widget_class_id, widget_path] = getMyTreeLocation(WidgetsLib.a1.Button);
	
		WidgetsLib.a1.Button.new_test();
		
		document.getElementById("t1").innerHTML = widget_class_id + "<br>" + widget_path;
		
		var b1 = WidgetsLib.a1.Button.new("w1", {
			name: "NNNNNNN",
			onclick: function(ev) {
				ev.target.style.color = "#ffff00";
				console.log("====== HERE");
			}
		});		

		document.getElementById("dbg").innerHTML = WidgetsLib.a1.Button.instances[0].name;
		
		for (var prop in WidgetsLib.a1.Button.instances[0]) {
			console.log("++" + prop + " = " + WidgetsLib.a1.Button.instances[0][prop]);
		}

#### Utility functions
		
		/////// UTILITY FUNCTIONS ////////
		function getMyTreeLocation(o) {
			var widget_class_id = "", widget_path = "";
			
			while (true) {
				widget_class_id = o.tree_name + widget_class_id;
				widget_path = o.tree_name + widget_path;
				o = o.tree_parent;
				if (o.tree_parent == null) {
					break;
				}
				widget_class_id = "_" + widget_class_id;
				widget_path = "." + widget_path;
			}
			return [widget_class_id, widget_path];
		}
	
		function addChildToTree(o, childName, childO) {
			o[childName] = childO;
			childO.tree_parent = o;
			childO.tree_name = childName;
		}
	
		function specialize_with(o, S) { for (var prop in S) { o[prop] = S[prop]; } }

#### and

	</script>

	</body>
	</html>

## Part 6. Better idea for `new()`

As you can notice, a `new()` is going to be pretty much the same for all widgets.
Therefore, we can put it somewhere as a utility function, and just call it as necessary
with appropriate parameters.

#### The `new()` would be:

	function typical_widget_new (dom_id, spec_o) {
		if (this.instances == null) { this.instances = []; }
		var instance_id = this.instances.length;
		var widget_class_id, widget_path, el;

		[widget_class_id, widget_path] = getMyTreeLocation(this);
		
		if (instance_id == 0) {	// first instance
			el = document.createElement('style');
			el.type = 'text/css';
			el.innerHTML = this.CSS_Literal
				.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id);
			document.getElementsByTagName('head')[0].appendChild(el);
		}
		
		var Widget = {
			// newly created widget
		};
		this.instances.push(Widget);
		
		specialize_with(Widget, spec_o);
		
		var base_el = document.getElementById(dom_id);
		el = document.createElement('div');
		specialize_with(el.style, base_el.style);
		base_el.replaceWith(el);
		el.setAttribute("id", dom_id);
		el.innerHTML = this.HTML_Literal
			.replace(/\{\{WIDGET_CLASS_ID\}\}/, widget_class_id)
			.replace(/\{\{WIDGET_INSTANCE\}\}/, `${widget_path}.instances[${instance_id}]`);

		Widget.DOM = el;
		return Widget;
	}

#### And a widget code

		// inside a js file of a widget class
		(function () {
			var Module_Path = [
				"WidgetsLib",
				"a1",
				"Button",
			];
		
			var curr = this;
			Module_Path.forEach(function(i){
				if (curr[i] == null) {
					addChildToTree(curr, i, {});
				}
				curr = curr[i];
			});
		
			specialize_with(curr, {
				CSS_Literal: `
					.{{WIDGET_CLASS_ID}}_Something {
						color: hsl(0, 0%, 20%);
					}
				`,
				HTML_Literal: `
					<div onclick="{{WIDGET_INSTANCE}}.onclick(event)"
						class="{{WIDGET_CLASS_ID}}_Something"
					>
					SOME SUPER COOL WIDGET
					</div>
				`,
				new: typical_widget_new,
			});
		})();

Let's re-format it a little bit:

		// inside a js file of a widget class
		(function () {
			var Module_Path = ["WidgetsLib", "a1", "Button"];
			var curr = this;
			Module_Path.forEach(function(i){if (curr[i] == null) {addChildToTree(curr, i, {})} curr = curr[i]});
		
			specialize_with(curr, {
				CSS_Literal: `
					.{{WIDGET_CLASS_ID}}_Something {
						color: hsl(0, 0%, 20%);
					}
				`,
				HTML_Literal: `
					<div onclick="{{WIDGET_INSTANCE}}.onclick(event)"
						class="{{WIDGET_CLASS_ID}}_Something"
					>
					SOME SUPER COOL WIDGET
					</div>
				`,
				new: typical_widget_new,
			});
		})();

Wow, now it look really good for re-use.

And again, here's how you use it:

		var b1 = WidgetsLib.a1.Button.new("w1", {
			name: "NNNNNNN",
			onclick: function(ev) {
				ev.target.style.color = "#ffff00";
				console.log("====== HERE");
			}
		});		

The End.

</textarea>
<div class="markdown-body" id="mydoc-res" style="max-width: 900px;">
<script src="showdown.js"></script>
<script>
	var converter = new showdown.Converter();
	converter.setOption('simplifiedAutoLink', true);
	converter.setOption('tables', true);
	converter.setOption('tasklists', true);
	var src = document.getElementById("mydoc-src");
	var res = document.getElementById("mydoc-res");
	res.innerHTML = converter.makeHtml(src.innerHTML);
	src.innerHTML = '';
</script>
</body> </html>
